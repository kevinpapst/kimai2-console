<?php

/*
 * This file is part of the Kimai 2 - Remote Console.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Kimai 2 - API Docs
 *
 * JSON API for the Kimai 2 time-tracking software. Read more about its usage in the [API documentation](https://www.kimai.org/documentation/rest-api.html) and then download a [Swagger file](doc.json) for import e.g. in Postman. Be aware: it is not yet considered stable and BC breaks might happen, but we try to avoid them.
 *
 * OpenAPI spec version: 0.4
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.10
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace KimaiConsole\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use KimaiConsole\Client\ApiException;
use KimaiConsole\Client\Configuration;
use KimaiConsole\Client\HeaderSelector;
use KimaiConsole\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @author   Swagger Codegen team
 * @see     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration $config
     * @param HeaderSelector $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiActivitiesGet
     *
     * Returns a collection of activities
     *
     * @param string $project Project ID to filter activities. If none is provided, all activities will be returned. (optional)
     * @param string $visible Visibility status to filter activities. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $globals Use if you want to fetch only global activities. Allowed values: true (default: false) (optional)
     * @param string $globals_first Deprecated parameter, value is not used any more (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, project (default: name) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ActivityCollection[]
     */
    public function apiActivitiesGet($project = null, $visible = null, $globals = null, $globals_first = null, $order_by = null, $order = null, $term = null)
    {
        list($response) = $this->apiActivitiesGetWithHttpInfo($project, $visible, $globals, $globals_first, $order_by, $order, $term);

        return $response;
    }

    /**
     * Operation apiActivitiesGetWithHttpInfo
     *
     * Returns a collection of activities
     *
     * @param string $project Project ID to filter activities. If none is provided, all activities will be returned. (optional)
     * @param string $visible Visibility status to filter activities. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $globals Use if you want to fetch only global activities. Allowed values: true (default: false) (optional)
     * @param string $globals_first Deprecated parameter, value is not used any more (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, project (default: name) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ActivityCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiActivitiesGetWithHttpInfo($project = null, $visible = null, $globals = null, $globals_first = null, $order_by = null, $order = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityCollection[]';
        $request = $this->apiActivitiesGetRequest($project, $visible, $globals, $globals_first, $order_by, $order, $term);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ActivityCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiActivitiesGetAsync
     *
     * Returns a collection of activities
     *
     * @param string $project Project ID to filter activities. If none is provided, all activities will be returned. (optional)
     * @param string $visible Visibility status to filter activities. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $globals Use if you want to fetch only global activities. Allowed values: true (default: false) (optional)
     * @param string $globals_first Deprecated parameter, value is not used any more (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, project (default: name) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesGetAsync($project = null, $visible = null, $globals = null, $globals_first = null, $order_by = null, $order = null, $term = null)
    {
        return $this->apiActivitiesGetAsyncWithHttpInfo($project, $visible, $globals, $globals_first, $order_by, $order, $term)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiActivitiesGetAsyncWithHttpInfo
     *
     * Returns a collection of activities
     *
     * @param string $project Project ID to filter activities. If none is provided, all activities will be returned. (optional)
     * @param string $visible Visibility status to filter activities. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $globals Use if you want to fetch only global activities. Allowed values: true (default: false) (optional)
     * @param string $globals_first Deprecated parameter, value is not used any more (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, project (default: name) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesGetAsyncWithHttpInfo($project = null, $visible = null, $globals = null, $globals_first = null, $order_by = null, $order = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityCollection[]';
        $request = $this->apiActivitiesGetRequest($project, $visible, $globals, $globals_first, $order_by, $order, $term);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiActivitiesGet'
     *
     * @param string $project Project ID to filter activities. If none is provided, all activities will be returned. (optional)
     * @param string $visible Visibility status to filter activities. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $globals Use if you want to fetch only global activities. Allowed values: true (default: false) (optional)
     * @param string $globals_first Deprecated parameter, value is not used any more (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, project (default: name) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiActivitiesGetRequest($project = null, $visible = null, $globals = null, $globals_first = null, $order_by = null, $order = null, $term = null)
    {
        if ($project !== null && !preg_match('/\\d+/', $project)) {
            throw new \InvalidArgumentException('invalid value for "project" when calling DefaultApi.apiActivitiesGet, must conform to the pattern /\\d+/.');
        }

        if ($visible !== null && !preg_match('/1|2|3/', $visible)) {
            throw new \InvalidArgumentException('invalid value for "visible" when calling DefaultApi.apiActivitiesGet, must conform to the pattern /1|2|3/.');
        }

        if ($globals !== null && !preg_match('/true/', $globals)) {
            throw new \InvalidArgumentException('invalid value for "globals" when calling DefaultApi.apiActivitiesGet, must conform to the pattern /true/.');
        }

        if ($globals_first !== null && !preg_match('/true|false/', $globals_first)) {
            throw new \InvalidArgumentException('invalid value for "globals_first" when calling DefaultApi.apiActivitiesGet, must conform to the pattern /true|false/.');
        }

        if ($order_by !== null && !preg_match('/id|name|project/', $order_by)) {
            throw new \InvalidArgumentException('invalid value for "order_by" when calling DefaultApi.apiActivitiesGet, must conform to the pattern /id|name|project/.');
        }

        if ($order !== null && !preg_match('/ASC|DESC/', $order)) {
            throw new \InvalidArgumentException('invalid value for "order" when calling DefaultApi.apiActivitiesGet, must conform to the pattern /ASC|DESC/.');
        }

        if ($term !== null && !preg_match('/[a-zA-Z0-9 \\-,:]+/', $term)) {
            throw new \InvalidArgumentException('invalid value for "term" when calling DefaultApi.apiActivitiesGet, must conform to the pattern /[a-zA-Z0-9 \\-,:]+/.');
        }

        $resourcePath = '/api/activities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($visible !== null) {
            $queryParams['visible'] = ObjectSerializer::toQueryValue($visible);
        }
        // query params
        if ($globals !== null) {
            $queryParams['globals'] = ObjectSerializer::toQueryValue($globals);
        }
        // query params
        if ($globals_first !== null) {
            $queryParams['globalsFirst'] = ObjectSerializer::toQueryValue($globals_first);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($term !== null) {
            $queryParams['term'] = ObjectSerializer::toQueryValue($term);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiActivitiesIdGet
     *
     * Returns one activity
     *
     * @param int $id Activity ID to fetch (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ActivityEntity
     */
    public function apiActivitiesIdGet($id)
    {
        list($response) = $this->apiActivitiesIdGetWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiActivitiesIdGetWithHttpInfo
     *
     * Returns one activity
     *
     * @param int $id Activity ID to fetch (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ActivityEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiActivitiesIdGetWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityEntity';
        $request = $this->apiActivitiesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ActivityEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiActivitiesIdGetAsync
     *
     * Returns one activity
     *
     * @param int $id Activity ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesIdGetAsync($id)
    {
        return $this->apiActivitiesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiActivitiesIdGetAsyncWithHttpInfo
     *
     * Returns one activity
     *
     * @param int $id Activity ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityEntity';
        $request = $this->apiActivitiesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiActivitiesIdGet'
     *
     * @param int $id Activity ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiActivitiesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiActivitiesIdGet'
            );
        }

        $resourcePath = '/api/activities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiActivitiesIdMetaPatch
     *
     * Sets the value of a meta-field for an existing activity.
     *
     * @param int $id Activity record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body $body body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ActivityEntity
     */
    public function apiActivitiesIdMetaPatch($id, $body = null)
    {
        list($response) = $this->apiActivitiesIdMetaPatchWithHttpInfo($id, $body);

        return $response;
    }

    /**
     * Operation apiActivitiesIdMetaPatchWithHttpInfo
     *
     * Sets the value of a meta-field for an existing activity.
     *
     * @param int $id Activity record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body $body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ActivityEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiActivitiesIdMetaPatchWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityEntity';
        $request = $this->apiActivitiesIdMetaPatchRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ActivityEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiActivitiesIdMetaPatchAsync
     *
     * Sets the value of a meta-field for an existing activity.
     *
     * @param int $id Activity record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesIdMetaPatchAsync($id, $body = null)
    {
        return $this->apiActivitiesIdMetaPatchAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiActivitiesIdMetaPatchAsyncWithHttpInfo
     *
     * Sets the value of a meta-field for an existing activity.
     *
     * @param int $id Activity record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesIdMetaPatchAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityEntity';
        $request = $this->apiActivitiesIdMetaPatchRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiActivitiesIdMetaPatch'
     *
     * @param int $id Activity record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiActivitiesIdMetaPatchRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiActivitiesIdMetaPatch'
            );
        }

        $resourcePath = '/api/activities/{id}/meta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiActivitiesIdPatch
     *
     * Update an existing activity
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body body (required)
     * @param int $id Activity ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ActivityEntity
     */
    public function apiActivitiesIdPatch($body, $id)
    {
        list($response) = $this->apiActivitiesIdPatchWithHttpInfo($body, $id);

        return $response;
    }

    /**
     * Operation apiActivitiesIdPatchWithHttpInfo
     *
     * Update an existing activity
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body (required)
     * @param int $id Activity ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ActivityEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiActivitiesIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityEntity';
        $request = $this->apiActivitiesIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ActivityEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiActivitiesIdPatchAsync
     *
     * Update an existing activity
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body (required)
     * @param int $id Activity ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesIdPatchAsync($body, $id)
    {
        return $this->apiActivitiesIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiActivitiesIdPatchAsyncWithHttpInfo
     *
     * Update an existing activity
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body (required)
     * @param int $id Activity ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityEntity';
        $request = $this->apiActivitiesIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiActivitiesIdPatch'
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body (required)
     * @param int $id Activity ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiActivitiesIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiActivitiesIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiActivitiesIdPatch'
            );
        }

        $resourcePath = '/api/activities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiActivitiesPost
     *
     * Creates a new activity
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ActivityEntity
     */
    public function apiActivitiesPost($body)
    {
        list($response) = $this->apiActivitiesPostWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation apiActivitiesPostWithHttpInfo
     *
     * Creates a new activity
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ActivityEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiActivitiesPostWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityEntity';
        $request = $this->apiActivitiesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ActivityEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiActivitiesPostAsync
     *
     * Creates a new activity
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesPostAsync($body)
    {
        return $this->apiActivitiesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiActivitiesPostAsyncWithHttpInfo
     *
     * Creates a new activity
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiActivitiesPostAsyncWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\ActivityEntity';
        $request = $this->apiActivitiesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiActivitiesPost'
     *
     * @param \KimaiConsole\Client\Model\ActivityEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiActivitiesPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiActivitiesPost'
            );
        }

        $resourcePath = '/api/activities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiConfigI18nGet
     *
     * Returns the user specific locale configuration
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\I18nConfig
     */
    public function apiConfigI18nGet()
    {
        list($response) = $this->apiConfigI18nGetWithHttpInfo();

        return $response;
    }

    /**
     * Operation apiConfigI18nGetWithHttpInfo
     *
     * Returns the user specific locale configuration
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\I18nConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiConfigI18nGetWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\I18nConfig';
        $request = $this->apiConfigI18nGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\I18nConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiConfigI18nGetAsync
     *
     * Returns the user specific locale configuration
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiConfigI18nGetAsync()
    {
        return $this->apiConfigI18nGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiConfigI18nGetAsyncWithHttpInfo
     *
     * Returns the user specific locale configuration
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiConfigI18nGetAsyncWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\I18nConfig';
        $request = $this->apiConfigI18nGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiConfigI18nGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiConfigI18nGetRequest()
    {
        $resourcePath = '/api/config/i18n';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiCustomersGet
     *
     * Returns a collection of customers
     *
     * @param string $visible Visibility status to filter activities (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\CustomerCollection[]
     */
    public function apiCustomersGet($visible = null, $order = null, $order_by = null, $term = null)
    {
        list($response) = $this->apiCustomersGetWithHttpInfo($visible, $order, $order_by, $term);

        return $response;
    }

    /**
     * Operation apiCustomersGetWithHttpInfo
     *
     * Returns a collection of customers
     *
     * @param string $visible Visibility status to filter activities (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\CustomerCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiCustomersGetWithHttpInfo($visible = null, $order = null, $order_by = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerCollection[]';
        $request = $this->apiCustomersGetRequest($visible, $order, $order_by, $term);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\CustomerCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiCustomersGetAsync
     *
     * Returns a collection of customers
     *
     * @param string $visible Visibility status to filter activities (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersGetAsync($visible = null, $order = null, $order_by = null, $term = null)
    {
        return $this->apiCustomersGetAsyncWithHttpInfo($visible, $order, $order_by, $term)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiCustomersGetAsyncWithHttpInfo
     *
     * Returns a collection of customers
     *
     * @param string $visible Visibility status to filter activities (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersGetAsyncWithHttpInfo($visible = null, $order = null, $order_by = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerCollection[]';
        $request = $this->apiCustomersGetRequest($visible, $order, $order_by, $term);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiCustomersGet'
     *
     * @param string $visible Visibility status to filter activities (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiCustomersGetRequest($visible = null, $order = null, $order_by = null, $term = null)
    {
        if ($visible !== null && !preg_match('/\\d+/', $visible)) {
            throw new \InvalidArgumentException('invalid value for "visible" when calling DefaultApi.apiCustomersGet, must conform to the pattern /\\d+/.');
        }

        if ($order !== null && !preg_match('/ASC|DESC/', $order)) {
            throw new \InvalidArgumentException('invalid value for "order" when calling DefaultApi.apiCustomersGet, must conform to the pattern /ASC|DESC/.');
        }

        if ($order_by !== null && !preg_match('/id|name/', $order_by)) {
            throw new \InvalidArgumentException('invalid value for "order_by" when calling DefaultApi.apiCustomersGet, must conform to the pattern /id|name/.');
        }

        if ($term !== null && !preg_match('/[a-zA-Z0-9 \\-,:]+/', $term)) {
            throw new \InvalidArgumentException('invalid value for "term" when calling DefaultApi.apiCustomersGet, must conform to the pattern /[a-zA-Z0-9 \\-,:]+/.');
        }

        $resourcePath = '/api/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($visible !== null) {
            $queryParams['visible'] = ObjectSerializer::toQueryValue($visible);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($term !== null) {
            $queryParams['term'] = ObjectSerializer::toQueryValue($term);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiCustomersIdGet
     *
     * Returns one customer
     *
     * @param string $id id (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\CustomerEntity
     */
    public function apiCustomersIdGet($id)
    {
        list($response) = $this->apiCustomersIdGetWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiCustomersIdGetWithHttpInfo
     *
     * Returns one customer
     *
     * @param string $id (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\CustomerEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiCustomersIdGetWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerEntity';
        $request = $this->apiCustomersIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\CustomerEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiCustomersIdGetAsync
     *
     * Returns one customer
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersIdGetAsync($id)
    {
        return $this->apiCustomersIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiCustomersIdGetAsyncWithHttpInfo
     *
     * Returns one customer
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerEntity';
        $request = $this->apiCustomersIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiCustomersIdGet'
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiCustomersIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiCustomersIdGet'
            );
        }

        $resourcePath = '/api/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiCustomersIdMetaPatch
     *
     * Sets the value of a meta-field for an existing customer.
     *
     * @param int $id Customer record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body1 $body body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\CustomerEntity
     */
    public function apiCustomersIdMetaPatch($id, $body = null)
    {
        list($response) = $this->apiCustomersIdMetaPatchWithHttpInfo($id, $body);

        return $response;
    }

    /**
     * Operation apiCustomersIdMetaPatchWithHttpInfo
     *
     * Sets the value of a meta-field for an existing customer.
     *
     * @param int $id Customer record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body1 $body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\CustomerEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiCustomersIdMetaPatchWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerEntity';
        $request = $this->apiCustomersIdMetaPatchRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\CustomerEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiCustomersIdMetaPatchAsync
     *
     * Sets the value of a meta-field for an existing customer.
     *
     * @param int $id Customer record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body1 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersIdMetaPatchAsync($id, $body = null)
    {
        return $this->apiCustomersIdMetaPatchAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiCustomersIdMetaPatchAsyncWithHttpInfo
     *
     * Sets the value of a meta-field for an existing customer.
     *
     * @param int $id Customer record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body1 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersIdMetaPatchAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerEntity';
        $request = $this->apiCustomersIdMetaPatchRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiCustomersIdMetaPatch'
     *
     * @param int $id Customer record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body1 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiCustomersIdMetaPatchRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiCustomersIdMetaPatch'
            );
        }

        $resourcePath = '/api/customers/{id}/meta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiCustomersIdPatch
     *
     * Update an existing customer
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body body (required)
     * @param int $id Customer ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\CustomerEntity
     */
    public function apiCustomersIdPatch($body, $id)
    {
        list($response) = $this->apiCustomersIdPatchWithHttpInfo($body, $id);

        return $response;
    }

    /**
     * Operation apiCustomersIdPatchWithHttpInfo
     *
     * Update an existing customer
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body (required)
     * @param int $id Customer ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\CustomerEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiCustomersIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerEntity';
        $request = $this->apiCustomersIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\CustomerEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiCustomersIdPatchAsync
     *
     * Update an existing customer
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body (required)
     * @param int $id Customer ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersIdPatchAsync($body, $id)
    {
        return $this->apiCustomersIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiCustomersIdPatchAsyncWithHttpInfo
     *
     * Update an existing customer
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body (required)
     * @param int $id Customer ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerEntity';
        $request = $this->apiCustomersIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiCustomersIdPatch'
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body (required)
     * @param int $id Customer ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiCustomersIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiCustomersIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiCustomersIdPatch'
            );
        }

        $resourcePath = '/api/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiCustomersPost
     *
     * Creates a new customer
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\CustomerEntity
     */
    public function apiCustomersPost($body)
    {
        list($response) = $this->apiCustomersPostWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation apiCustomersPostWithHttpInfo
     *
     * Creates a new customer
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\CustomerEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiCustomersPostWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerEntity';
        $request = $this->apiCustomersPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\CustomerEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiCustomersPostAsync
     *
     * Creates a new customer
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersPostAsync($body)
    {
        return $this->apiCustomersPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiCustomersPostAsyncWithHttpInfo
     *
     * Creates a new customer
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiCustomersPostAsyncWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\CustomerEntity';
        $request = $this->apiCustomersPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiCustomersPost'
     *
     * @param \KimaiConsole\Client\Model\CustomerEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiCustomersPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiCustomersPost'
            );
        }

        $resourcePath = '/api/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiExpensesGet
     *
     * Returns a collection of expenses
     *
     * @param string $order_by The field by which results will be ordered. Allowed values: begin, end, duration, total, category, cost, user, customer, project, activity, description, exported, refundable, multiplier (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $refundable Use this flag if you want to filter for refundable expenses. Allowed values: 0&#x3D;not refundable, 1&#x3D;refundable (default: all) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $term Free search term (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ExpenseCollection[]
     */
    public function apiExpensesGet($order_by = null, $order = null, $begin = null, $end = null, $refundable = null, $exported = null, $term = null, $page = null, $size = null)
    {
        list($response) = $this->apiExpensesGetWithHttpInfo($order_by, $order, $begin, $end, $refundable, $exported, $term, $page, $size);

        return $response;
    }

    /**
     * Operation apiExpensesGetWithHttpInfo
     *
     * Returns a collection of expenses
     *
     * @param string $order_by The field by which results will be ordered. Allowed values: begin, end, duration, total, category, cost, user, customer, project, activity, description, exported, refundable, multiplier (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $refundable Use this flag if you want to filter for refundable expenses. Allowed values: 0&#x3D;not refundable, 1&#x3D;refundable (default: all) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $term Free search term (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ExpenseCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiExpensesGetWithHttpInfo($order_by = null, $order = null, $begin = null, $end = null, $refundable = null, $exported = null, $term = null, $page = null, $size = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ExpenseCollection[]';
        $request = $this->apiExpensesGetRequest($order_by, $order, $begin, $end, $refundable, $exported, $term, $page, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ExpenseCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiExpensesGetAsync
     *
     * Returns a collection of expenses
     *
     * @param string $order_by The field by which results will be ordered. Allowed values: begin, end, duration, total, category, cost, user, customer, project, activity, description, exported, refundable, multiplier (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $refundable Use this flag if you want to filter for refundable expenses. Allowed values: 0&#x3D;not refundable, 1&#x3D;refundable (default: all) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $term Free search term (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesGetAsync($order_by = null, $order = null, $begin = null, $end = null, $refundable = null, $exported = null, $term = null, $page = null, $size = null)
    {
        return $this->apiExpensesGetAsyncWithHttpInfo($order_by, $order, $begin, $end, $refundable, $exported, $term, $page, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiExpensesGetAsyncWithHttpInfo
     *
     * Returns a collection of expenses
     *
     * @param string $order_by The field by which results will be ordered. Allowed values: begin, end, duration, total, category, cost, user, customer, project, activity, description, exported, refundable, multiplier (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $refundable Use this flag if you want to filter for refundable expenses. Allowed values: 0&#x3D;not refundable, 1&#x3D;refundable (default: all) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $term Free search term (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesGetAsyncWithHttpInfo($order_by = null, $order = null, $begin = null, $end = null, $refundable = null, $exported = null, $term = null, $page = null, $size = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ExpenseCollection[]';
        $request = $this->apiExpensesGetRequest($order_by, $order, $begin, $end, $refundable, $exported, $term, $page, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiExpensesGet'
     *
     * @param string $order_by The field by which results will be ordered. Allowed values: begin, end, duration, total, category, cost, user, customer, project, activity, description, exported, refundable, multiplier (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $refundable Use this flag if you want to filter for refundable expenses. Allowed values: 0&#x3D;not refundable, 1&#x3D;refundable (default: all) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $term Free search term (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiExpensesGetRequest($order_by = null, $order = null, $begin = null, $end = null, $refundable = null, $exported = null, $term = null, $page = null, $size = null)
    {
        if ($order_by !== null && !preg_match('/begin|end|duration|total|category|cost|user|customer|project|activity|description|exported|refundable|multiplier/', $order_by)) {
            throw new \InvalidArgumentException('invalid value for "order_by" when calling DefaultApi.apiExpensesGet, must conform to the pattern /begin|end|duration|total|category|cost|user|customer|project|activity|description|exported|refundable|multiplier/.');
        }

        if ($order !== null && !preg_match('/ASC|DESC/', $order)) {
            throw new \InvalidArgumentException('invalid value for "order" when calling DefaultApi.apiExpensesGet, must conform to the pattern /ASC|DESC/.');
        }

        if ($refundable !== null && !preg_match('/0|1/', $refundable)) {
            throw new \InvalidArgumentException('invalid value for "refundable" when calling DefaultApi.apiExpensesGet, must conform to the pattern /0|1/.');
        }

        if ($exported !== null && !preg_match('/0|1/', $exported)) {
            throw new \InvalidArgumentException('invalid value for "exported" when calling DefaultApi.apiExpensesGet, must conform to the pattern /0|1/.');
        }

        if ($term !== null && !preg_match('/[a-zA-Z0-9 \\-,:]+/', $term)) {
            throw new \InvalidArgumentException('invalid value for "term" when calling DefaultApi.apiExpensesGet, must conform to the pattern /[a-zA-Z0-9 \\-,:]+/.');
        }

        if ($page !== null && !preg_match('/\\d+/', $page)) {
            throw new \InvalidArgumentException('invalid value for "page" when calling DefaultApi.apiExpensesGet, must conform to the pattern /\\d+/.');
        }

        if ($size !== null && !preg_match('/\\d+/', $size)) {
            throw new \InvalidArgumentException('invalid value for "size" when calling DefaultApi.apiExpensesGet, must conform to the pattern /\\d+/.');
        }

        $resourcePath = '/api/expenses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($begin !== null) {
            $queryParams['begin'] = ObjectSerializer::toQueryValue($begin);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end);
        }
        // query params
        if ($refundable !== null) {
            $queryParams['refundable'] = ObjectSerializer::toQueryValue($refundable);
        }
        // query params
        if ($exported !== null) {
            $queryParams['exported'] = ObjectSerializer::toQueryValue($exported);
        }
        // query params
        if ($term !== null) {
            $queryParams['term'] = ObjectSerializer::toQueryValue($term);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiExpensesIdDelete
     *
     * Delete an existing expense record
     *
     * @param int $id Expense record ID to delete (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function apiExpensesIdDelete($id)
    {
        $this->apiExpensesIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation apiExpensesIdDeleteWithHttpInfo
     *
     * Delete an existing expense record
     *
     * @param int $id Expense record ID to delete (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiExpensesIdDeleteWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiExpensesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiExpensesIdDeleteAsync
     *
     * Delete an existing expense record
     *
     * @param int $id Expense record ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesIdDeleteAsync($id)
    {
        return $this->apiExpensesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiExpensesIdDeleteAsyncWithHttpInfo
     *
     * Delete an existing expense record
     *
     * @param int $id Expense record ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiExpensesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiExpensesIdDelete'
     *
     * @param int $id Expense record ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiExpensesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiExpensesIdDelete'
            );
        }

        $resourcePath = '/api/expenses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiExpensesIdGet
     *
     * Returns one expense
     *
     * @param int $id Expense ID to fetch (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ExpenseEntity
     */
    public function apiExpensesIdGet($id)
    {
        list($response) = $this->apiExpensesIdGetWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiExpensesIdGetWithHttpInfo
     *
     * Returns one expense
     *
     * @param int $id Expense ID to fetch (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ExpenseEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiExpensesIdGetWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\ExpenseEntity';
        $request = $this->apiExpensesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ExpenseEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiExpensesIdGetAsync
     *
     * Returns one expense
     *
     * @param int $id Expense ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesIdGetAsync($id)
    {
        return $this->apiExpensesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiExpensesIdGetAsyncWithHttpInfo
     *
     * Returns one expense
     *
     * @param int $id Expense ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\ExpenseEntity';
        $request = $this->apiExpensesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiExpensesIdGet'
     *
     * @param int $id Expense ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiExpensesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiExpensesIdGet'
            );
        }

        $resourcePath = '/api/expenses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiExpensesIdPatch
     *
     * Update an existing expense
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body body (required)
     * @param int $id Expense ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ExpenseEntity
     */
    public function apiExpensesIdPatch($body, $id)
    {
        list($response) = $this->apiExpensesIdPatchWithHttpInfo($body, $id);

        return $response;
    }

    /**
     * Operation apiExpensesIdPatchWithHttpInfo
     *
     * Update an existing expense
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body (required)
     * @param int $id Expense ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ExpenseEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiExpensesIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\ExpenseEntity';
        $request = $this->apiExpensesIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ExpenseEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiExpensesIdPatchAsync
     *
     * Update an existing expense
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body (required)
     * @param int $id Expense ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesIdPatchAsync($body, $id)
    {
        return $this->apiExpensesIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiExpensesIdPatchAsyncWithHttpInfo
     *
     * Update an existing expense
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body (required)
     * @param int $id Expense ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\ExpenseEntity';
        $request = $this->apiExpensesIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiExpensesIdPatch'
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body (required)
     * @param int $id Expense ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiExpensesIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiExpensesIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiExpensesIdPatch'
            );
        }

        $resourcePath = '/api/expenses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiExpensesPost
     *
     * Creates a new expense
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ExpenseEntity
     */
    public function apiExpensesPost($body)
    {
        list($response) = $this->apiExpensesPostWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation apiExpensesPostWithHttpInfo
     *
     * Creates a new expense
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ExpenseEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiExpensesPostWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\ExpenseEntity';
        $request = $this->apiExpensesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ExpenseEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiExpensesPostAsync
     *
     * Creates a new expense
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesPostAsync($body)
    {
        return $this->apiExpensesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiExpensesPostAsyncWithHttpInfo
     *
     * Creates a new expense
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiExpensesPostAsyncWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\ExpenseEntity';
        $request = $this->apiExpensesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiExpensesPost'
     *
     * @param \KimaiConsole\Client\Model\ExpenseEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiExpensesPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiExpensesPost'
            );
        }

        $resourcePath = '/api/expenses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiPingGet
     *
     * A testing route for the API
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function apiPingGet()
    {
        $this->apiPingGetWithHttpInfo();
    }

    /**
     * Operation apiPingGetWithHttpInfo
     *
     * A testing route for the API
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiPingGetWithHttpInfo()
    {
        $returnType = '';
        $request = $this->apiPingGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiPingGetAsync
     *
     * A testing route for the API
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiPingGetAsync()
    {
        return $this->apiPingGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiPingGetAsyncWithHttpInfo
     *
     * A testing route for the API
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiPingGetAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->apiPingGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiPingGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiPingGetRequest()
    {
        $resourcePath = '/api/ping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiProjectsGet
     *
     * Returns a collection of projects
     *
     * @param string $customer Customer ID to filter projects (optional)
     * @param string $visible Visibility status to filter projects (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, customer (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ProjectCollection[]
     */
    public function apiProjectsGet($customer = null, $visible = null, $order = null, $order_by = null, $term = null)
    {
        list($response) = $this->apiProjectsGetWithHttpInfo($customer, $visible, $order, $order_by, $term);

        return $response;
    }

    /**
     * Operation apiProjectsGetWithHttpInfo
     *
     * Returns a collection of projects
     *
     * @param string $customer Customer ID to filter projects (optional)
     * @param string $visible Visibility status to filter projects (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, customer (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ProjectCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiProjectsGetWithHttpInfo($customer = null, $visible = null, $order = null, $order_by = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectCollection[]';
        $request = $this->apiProjectsGetRequest($customer, $visible, $order, $order_by, $term);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ProjectCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiProjectsGetAsync
     *
     * Returns a collection of projects
     *
     * @param string $customer Customer ID to filter projects (optional)
     * @param string $visible Visibility status to filter projects (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, customer (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsGetAsync($customer = null, $visible = null, $order = null, $order_by = null, $term = null)
    {
        return $this->apiProjectsGetAsyncWithHttpInfo($customer, $visible, $order, $order_by, $term)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiProjectsGetAsyncWithHttpInfo
     *
     * Returns a collection of projects
     *
     * @param string $customer Customer ID to filter projects (optional)
     * @param string $visible Visibility status to filter projects (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, customer (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsGetAsyncWithHttpInfo($customer = null, $visible = null, $order = null, $order_by = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectCollection[]';
        $request = $this->apiProjectsGetRequest($customer, $visible, $order, $order_by, $term);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiProjectsGet'
     *
     * @param string $customer Customer ID to filter projects (optional)
     * @param string $visible Visibility status to filter projects (1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;both) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, name, customer (default: name) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiProjectsGetRequest($customer = null, $visible = null, $order = null, $order_by = null, $term = null)
    {
        if ($customer !== null && !preg_match('/\\d+/', $customer)) {
            throw new \InvalidArgumentException('invalid value for "customer" when calling DefaultApi.apiProjectsGet, must conform to the pattern /\\d+/.');
        }

        if ($visible !== null && !preg_match('/\\d+/', $visible)) {
            throw new \InvalidArgumentException('invalid value for "visible" when calling DefaultApi.apiProjectsGet, must conform to the pattern /\\d+/.');
        }

        if ($order !== null && !preg_match('/ASC|DESC/', $order)) {
            throw new \InvalidArgumentException('invalid value for "order" when calling DefaultApi.apiProjectsGet, must conform to the pattern /ASC|DESC/.');
        }

        if ($order_by !== null && !preg_match('/id|name|customer/', $order_by)) {
            throw new \InvalidArgumentException('invalid value for "order_by" when calling DefaultApi.apiProjectsGet, must conform to the pattern /id|name|customer/.');
        }

        if ($term !== null && !preg_match('/[a-zA-Z0-9 \\-,:]+/', $term)) {
            throw new \InvalidArgumentException('invalid value for "term" when calling DefaultApi.apiProjectsGet, must conform to the pattern /[a-zA-Z0-9 \\-,:]+/.');
        }

        $resourcePath = '/api/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer);
        }
        // query params
        if ($visible !== null) {
            $queryParams['visible'] = ObjectSerializer::toQueryValue($visible);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($term !== null) {
            $queryParams['term'] = ObjectSerializer::toQueryValue($term);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiProjectsIdGet
     *
     * Returns one project
     *
     * @param string $id id (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ProjectEntity
     */
    public function apiProjectsIdGet($id)
    {
        list($response) = $this->apiProjectsIdGetWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiProjectsIdGetWithHttpInfo
     *
     * Returns one project
     *
     * @param string $id (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ProjectEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiProjectsIdGetWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectEntity';
        $request = $this->apiProjectsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ProjectEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiProjectsIdGetAsync
     *
     * Returns one project
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsIdGetAsync($id)
    {
        return $this->apiProjectsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiProjectsIdGetAsyncWithHttpInfo
     *
     * Returns one project
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectEntity';
        $request = $this->apiProjectsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiProjectsIdGet'
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiProjectsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiProjectsIdGet'
            );
        }

        $resourcePath = '/api/projects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiProjectsIdMetaPatch
     *
     * Sets the value of a meta-field for an existing project.
     *
     * @param int $id Project record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body2 $body body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ProjectEntity
     */
    public function apiProjectsIdMetaPatch($id, $body = null)
    {
        list($response) = $this->apiProjectsIdMetaPatchWithHttpInfo($id, $body);

        return $response;
    }

    /**
     * Operation apiProjectsIdMetaPatchWithHttpInfo
     *
     * Sets the value of a meta-field for an existing project.
     *
     * @param int $id Project record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body2 $body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ProjectEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiProjectsIdMetaPatchWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectEntity';
        $request = $this->apiProjectsIdMetaPatchRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ProjectEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiProjectsIdMetaPatchAsync
     *
     * Sets the value of a meta-field for an existing project.
     *
     * @param int $id Project record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body2 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsIdMetaPatchAsync($id, $body = null)
    {
        return $this->apiProjectsIdMetaPatchAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiProjectsIdMetaPatchAsyncWithHttpInfo
     *
     * Sets the value of a meta-field for an existing project.
     *
     * @param int $id Project record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body2 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsIdMetaPatchAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectEntity';
        $request = $this->apiProjectsIdMetaPatchRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiProjectsIdMetaPatch'
     *
     * @param int $id Project record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body2 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiProjectsIdMetaPatchRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiProjectsIdMetaPatch'
            );
        }

        $resourcePath = '/api/projects/{id}/meta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiProjectsIdPatch
     *
     * Update an existing project
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body body (required)
     * @param int $id Project ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ProjectEntity
     */
    public function apiProjectsIdPatch($body, $id)
    {
        list($response) = $this->apiProjectsIdPatchWithHttpInfo($body, $id);

        return $response;
    }

    /**
     * Operation apiProjectsIdPatchWithHttpInfo
     *
     * Update an existing project
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body (required)
     * @param int $id Project ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ProjectEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiProjectsIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectEntity';
        $request = $this->apiProjectsIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ProjectEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiProjectsIdPatchAsync
     *
     * Update an existing project
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body (required)
     * @param int $id Project ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsIdPatchAsync($body, $id)
    {
        return $this->apiProjectsIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiProjectsIdPatchAsyncWithHttpInfo
     *
     * Update an existing project
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body (required)
     * @param int $id Project ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectEntity';
        $request = $this->apiProjectsIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiProjectsIdPatch'
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body (required)
     * @param int $id Project ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiProjectsIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiProjectsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiProjectsIdPatch'
            );
        }

        $resourcePath = '/api/projects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiProjectsPost
     *
     * Creates a new project
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\ProjectEntity
     */
    public function apiProjectsPost($body)
    {
        list($response) = $this->apiProjectsPostWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation apiProjectsPostWithHttpInfo
     *
     * Creates a new project
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\ProjectEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiProjectsPostWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectEntity';
        $request = $this->apiProjectsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\ProjectEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiProjectsPostAsync
     *
     * Creates a new project
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsPostAsync($body)
    {
        return $this->apiProjectsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiProjectsPostAsyncWithHttpInfo
     *
     * Creates a new project
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiProjectsPostAsyncWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\ProjectEntity';
        $request = $this->apiProjectsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiProjectsPost'
     *
     * @param \KimaiConsole\Client\Model\ProjectEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiProjectsPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiProjectsPost'
            );
        }

        $resourcePath = '/api/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTagsGet
     *
     * Fetch all existing tags
     *
     * @param string $name Search term to filter tag list (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function apiTagsGet($name = null)
    {
        list($response) = $this->apiTagsGetWithHttpInfo($name);

        return $response;
    }

    /**
     * Operation apiTagsGetWithHttpInfo
     *
     * Fetch all existing tags
     *
     * @param string $name Search term to filter tag list (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTagsGetWithHttpInfo($name = null)
    {
        $returnType = 'string[]';
        $request = $this->apiTagsGetRequest($name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTagsGetAsync
     *
     * Fetch all existing tags
     *
     * @param string $name Search term to filter tag list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTagsGetAsync($name = null)
    {
        return $this->apiTagsGetAsyncWithHttpInfo($name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTagsGetAsyncWithHttpInfo
     *
     * Fetch all existing tags
     *
     * @param string $name Search term to filter tag list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTagsGetAsyncWithHttpInfo($name = null)
    {
        $returnType = 'string[]';
        $request = $this->apiTagsGetRequest($name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTagsGet'
     *
     * @param string $name Search term to filter tag list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTagsGetRequest($name = null)
    {
        $resourcePath = '/api/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTagsIdDelete
     *
     * Delete a tag
     *
     * @param int $id Tag ID to delete (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function apiTagsIdDelete($id)
    {
        $this->apiTagsIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation apiTagsIdDeleteWithHttpInfo
     *
     * Delete a tag
     *
     * @param int $id Tag ID to delete (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTagsIdDeleteWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiTagsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiTagsIdDeleteAsync
     *
     * Delete a tag
     *
     * @param int $id Tag ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTagsIdDeleteAsync($id)
    {
        return $this->apiTagsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTagsIdDeleteAsyncWithHttpInfo
     *
     * Delete a tag
     *
     * @param int $id Tag ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTagsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiTagsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTagsIdDelete'
     *
     * @param int $id Tag ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTagsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTagsIdDelete'
            );
        }

        $resourcePath = '/api/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTagsPost
     *
     * Creates a new tag
     *
     * @param \KimaiConsole\Client\Model\TagEditForm $body body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TagEntity
     */
    public function apiTagsPost($body)
    {
        list($response) = $this->apiTagsPostWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation apiTagsPostWithHttpInfo
     *
     * Creates a new tag
     *
     * @param \KimaiConsole\Client\Model\TagEditForm $body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TagEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTagsPostWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\TagEntity';
        $request = $this->apiTagsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TagEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTagsPostAsync
     *
     * Creates a new tag
     *
     * @param \KimaiConsole\Client\Model\TagEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTagsPostAsync($body)
    {
        return $this->apiTagsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTagsPostAsyncWithHttpInfo
     *
     * Creates a new tag
     *
     * @param \KimaiConsole\Client\Model\TagEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTagsPostAsyncWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\TagEntity';
        $request = $this->apiTagsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTagsPost'
     *
     * @param \KimaiConsole\Client\Model\TagEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTagsPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiTagsPost'
            );
        }

        $resourcePath = '/api/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsGet
     *
     * Fetch all existing teams
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TeamCollection[]
     */
    public function apiTeamsGet()
    {
        list($response) = $this->apiTeamsGetWithHttpInfo();

        return $response;
    }

    /**
     * Operation apiTeamsGetWithHttpInfo
     *
     * Fetch all existing teams
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TeamCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsGetWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\TeamCollection[]';
        $request = $this->apiTeamsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TeamCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTeamsGetAsync
     *
     * Fetch all existing teams
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsGetAsync()
    {
        return $this->apiTeamsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsGetAsyncWithHttpInfo
     *
     * Fetch all existing teams
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsGetAsyncWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\TeamCollection[]';
        $request = $this->apiTeamsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTeamsGetRequest()
    {
        $resourcePath = '/api/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdDelete
     *
     * Delete a team
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function apiTeamsIdDelete($id)
    {
        $this->apiTeamsIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation apiTeamsIdDeleteWithHttpInfo
     *
     * Delete a team
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdDeleteWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiTeamsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdDeleteAsync
     *
     * Delete a team
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdDeleteAsync($id)
    {
        return $this->apiTeamsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdDeleteAsyncWithHttpInfo
     *
     * Delete a team
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiTeamsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdDelete'
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTeamsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTeamsIdDelete'
            );
        }

        $resourcePath = '/api/teams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdGet
     *
     * Returns one team
     *
     * @param string $id id (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TeamEntity
     */
    public function apiTeamsIdGet($id)
    {
        list($response) = $this->apiTeamsIdGetWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiTeamsIdGetWithHttpInfo
     *
     * Returns one team
     *
     * @param string $id (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdGetWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\TeamEntity';
        $request = $this->apiTeamsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdGetAsync
     *
     * Returns one team
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdGetAsync($id)
    {
        return $this->apiTeamsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdGetAsyncWithHttpInfo
     *
     * Returns one team
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\TeamEntity';
        $request = $this->apiTeamsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdGet'
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTeamsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTeamsIdGet'
            );
        }

        $resourcePath = '/api/teams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsActiveGet
     *
     * Returns the collection of active timesheet records
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetSubCollection[]
     */
    public function apiTimesheetsActiveGet()
    {
        list($response) = $this->apiTimesheetsActiveGetWithHttpInfo();

        return $response;
    }

    /**
     * Operation apiTimesheetsActiveGetWithHttpInfo
     *
     * Returns the collection of active timesheet records
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetSubCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsActiveGetWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetSubCollection[]';
        $request = $this->apiTimesheetsActiveGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetSubCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsActiveGetAsync
     *
     * Returns the collection of active timesheet records
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsActiveGetAsync()
    {
        return $this->apiTimesheetsActiveGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsActiveGetAsyncWithHttpInfo
     *
     * Returns the collection of active timesheet records
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsActiveGetAsyncWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetSubCollection[]';
        $request = $this->apiTimesheetsActiveGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsActiveGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsActiveGetRequest()
    {
        $resourcePath = '/api/timesheets/active';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsGet
     *
     * Returns a collection of timesheet records
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $customer Customer ID to filter timesheets (optional)
     * @param string $project Project ID to filter timesheets (optional)
     * @param string $activity Activity ID to filter timesheets (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     * @param string $tags The name of tags which are in the datasets (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, begin, end, rate (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $active Filter for running/active records. Allowed values: 0&#x3D;stopped, 1&#x3D;active (default: all) (optional)
     * @param string $full Allows to fetch fully serialized objects including subresources (TimesheetSubCollection). Allowed values: true (default: false) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetCollection[]
     */
    public function apiTimesheetsGet($user = null, $customer = null, $project = null, $activity = null, $page = null, $size = null, $tags = null, $order_by = null, $order = null, $begin = null, $end = null, $exported = null, $active = null, $full = null, $term = null)
    {
        list($response) = $this->apiTimesheetsGetWithHttpInfo($user, $customer, $project, $activity, $page, $size, $tags, $order_by, $order, $begin, $end, $exported, $active, $full, $term);

        return $response;
    }

    /**
     * Operation apiTimesheetsGetWithHttpInfo
     *
     * Returns a collection of timesheet records
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $customer Customer ID to filter timesheets (optional)
     * @param string $project Project ID to filter timesheets (optional)
     * @param string $activity Activity ID to filter timesheets (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     * @param string $tags The name of tags which are in the datasets (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, begin, end, rate (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $active Filter for running/active records. Allowed values: 0&#x3D;stopped, 1&#x3D;active (default: all) (optional)
     * @param string $full Allows to fetch fully serialized objects including subresources (TimesheetSubCollection). Allowed values: true (default: false) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsGetWithHttpInfo($user = null, $customer = null, $project = null, $activity = null, $page = null, $size = null, $tags = null, $order_by = null, $order = null, $begin = null, $end = null, $exported = null, $active = null, $full = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetCollection[]';
        $request = $this->apiTimesheetsGetRequest($user, $customer, $project, $activity, $page, $size, $tags, $order_by, $order, $begin, $end, $exported, $active, $full, $term);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsGetAsync
     *
     * Returns a collection of timesheet records
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $customer Customer ID to filter timesheets (optional)
     * @param string $project Project ID to filter timesheets (optional)
     * @param string $activity Activity ID to filter timesheets (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     * @param string $tags The name of tags which are in the datasets (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, begin, end, rate (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $active Filter for running/active records. Allowed values: 0&#x3D;stopped, 1&#x3D;active (default: all) (optional)
     * @param string $full Allows to fetch fully serialized objects including subresources (TimesheetSubCollection). Allowed values: true (default: false) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsGetAsync($user = null, $customer = null, $project = null, $activity = null, $page = null, $size = null, $tags = null, $order_by = null, $order = null, $begin = null, $end = null, $exported = null, $active = null, $full = null, $term = null)
    {
        return $this->apiTimesheetsGetAsyncWithHttpInfo($user, $customer, $project, $activity, $page, $size, $tags, $order_by, $order, $begin, $end, $exported, $active, $full, $term)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsGetAsyncWithHttpInfo
     *
     * Returns a collection of timesheet records
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $customer Customer ID to filter timesheets (optional)
     * @param string $project Project ID to filter timesheets (optional)
     * @param string $activity Activity ID to filter timesheets (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     * @param string $tags The name of tags which are in the datasets (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, begin, end, rate (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $active Filter for running/active records. Allowed values: 0&#x3D;stopped, 1&#x3D;active (default: all) (optional)
     * @param string $full Allows to fetch fully serialized objects including subresources (TimesheetSubCollection). Allowed values: true (default: false) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsGetAsyncWithHttpInfo($user = null, $customer = null, $project = null, $activity = null, $page = null, $size = null, $tags = null, $order_by = null, $order = null, $begin = null, $end = null, $exported = null, $active = null, $full = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetCollection[]';
        $request = $this->apiTimesheetsGetRequest($user, $customer, $project, $activity, $page, $size, $tags, $order_by, $order, $begin, $end, $exported, $active, $full, $term);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsGet'
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $customer Customer ID to filter timesheets (optional)
     * @param string $project Project ID to filter timesheets (optional)
     * @param string $activity Activity ID to filter timesheets (optional)
     * @param string $page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param string $size The amount of entries for each page (default: 50) (optional)
     * @param string $tags The name of tags which are in the datasets (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, begin, end, rate (default: begin) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param string $begin Only records after this date will be included (format: HTML5) (optional)
     * @param string $end Only records before this date will be included (format: HTML5) (optional)
     * @param string $exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param string $active Filter for running/active records. Allowed values: 0&#x3D;stopped, 1&#x3D;active (default: all) (optional)
     * @param string $full Allows to fetch fully serialized objects including subresources (TimesheetSubCollection). Allowed values: true (default: false) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsGetRequest($user = null, $customer = null, $project = null, $activity = null, $page = null, $size = null, $tags = null, $order_by = null, $order = null, $begin = null, $end = null, $exported = null, $active = null, $full = null, $term = null)
    {
        if ($user !== null && !preg_match('/\\d+|all/', $user)) {
            throw new \InvalidArgumentException('invalid value for "user" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /\\d+|all/.');
        }

        if ($customer !== null && !preg_match('/\\d+/', $customer)) {
            throw new \InvalidArgumentException('invalid value for "customer" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /\\d+/.');
        }

        if ($project !== null && !preg_match('/\\d+/', $project)) {
            throw new \InvalidArgumentException('invalid value for "project" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /\\d+/.');
        }

        if ($activity !== null && !preg_match('/\\d+/', $activity)) {
            throw new \InvalidArgumentException('invalid value for "activity" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /\\d+/.');
        }

        if ($page !== null && !preg_match('/\\d+/', $page)) {
            throw new \InvalidArgumentException('invalid value for "page" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /\\d+/.');
        }

        if ($size !== null && !preg_match('/\\d+/', $size)) {
            throw new \InvalidArgumentException('invalid value for "size" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /\\d+/.');
        }

        if ($order_by !== null && !preg_match('/id|begin|end|rate/', $order_by)) {
            throw new \InvalidArgumentException('invalid value for "order_by" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /id|begin|end|rate/.');
        }

        if ($order !== null && !preg_match('/ASC|DESC/', $order)) {
            throw new \InvalidArgumentException('invalid value for "order" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /ASC|DESC/.');
        }

        if ($exported !== null && !preg_match('/0|1/', $exported)) {
            throw new \InvalidArgumentException('invalid value for "exported" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /0|1/.');
        }

        if ($active !== null && !preg_match('/0|1/', $active)) {
            throw new \InvalidArgumentException('invalid value for "active" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /0|1/.');
        }

        if ($full !== null && !preg_match('/true/', $full)) {
            throw new \InvalidArgumentException('invalid value for "full" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /true/.');
        }

        if ($term !== null && !preg_match('/[a-zA-Z0-9 \\-,:]+/', $term)) {
            throw new \InvalidArgumentException('invalid value for "term" when calling DefaultApi.apiTimesheetsGet, must conform to the pattern /[a-zA-Z0-9 \\-,:]+/.');
        }

        $resourcePath = '/api/timesheets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($user !== null) {
            $queryParams['user'] = ObjectSerializer::toQueryValue($user);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($activity !== null) {
            $queryParams['activity'] = ObjectSerializer::toQueryValue($activity);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }
        // query params
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($begin !== null) {
            $queryParams['begin'] = ObjectSerializer::toQueryValue($begin);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end);
        }
        // query params
        if ($exported !== null) {
            $queryParams['exported'] = ObjectSerializer::toQueryValue($exported);
        }
        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active);
        }
        // query params
        if ($full !== null) {
            $queryParams['full'] = ObjectSerializer::toQueryValue($full);
        }
        // query params
        if ($term !== null) {
            $queryParams['term'] = ObjectSerializer::toQueryValue($term);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsIdDelete
     *
     * Delete an existing timesheet record
     *
     * @param int $id Timesheet record ID to delete (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function apiTimesheetsIdDelete($id)
    {
        $this->apiTimesheetsIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation apiTimesheetsIdDeleteWithHttpInfo
     *
     * Delete an existing timesheet record
     *
     * @param int $id Timesheet record ID to delete (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsIdDeleteWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiTimesheetsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsIdDeleteAsync
     *
     * Delete an existing timesheet record
     *
     * @param int $id Timesheet record ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdDeleteAsync($id)
    {
        return $this->apiTimesheetsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsIdDeleteAsyncWithHttpInfo
     *
     * Delete an existing timesheet record
     *
     * @param int $id Timesheet record ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiTimesheetsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsIdDelete'
     *
     * @param int $id Timesheet record ID to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTimesheetsIdDelete'
            );
        }

        $resourcePath = '/api/timesheets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsIdExportPatch
     *
     * Switch the export state of a timesheet record to (un-)lock it
     *
     * @param int $id Timesheet record ID to switch export state (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetEntity
     */
    public function apiTimesheetsIdExportPatch($id)
    {
        list($response) = $this->apiTimesheetsIdExportPatchWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiTimesheetsIdExportPatchWithHttpInfo
     *
     * Switch the export state of a timesheet record to (un-)lock it
     *
     * @param int $id Timesheet record ID to switch export state (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsIdExportPatchWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdExportPatchRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsIdExportPatchAsync
     *
     * Switch the export state of a timesheet record to (un-)lock it
     *
     * @param int $id Timesheet record ID to switch export state (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdExportPatchAsync($id)
    {
        return $this->apiTimesheetsIdExportPatchAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsIdExportPatchAsyncWithHttpInfo
     *
     * Switch the export state of a timesheet record to (un-)lock it
     *
     * @param int $id Timesheet record ID to switch export state (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdExportPatchAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdExportPatchRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsIdExportPatch'
     *
     * @param int $id Timesheet record ID to switch export state (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsIdExportPatchRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTimesheetsIdExportPatch'
            );
        }

        $resourcePath = '/api/timesheets/{id}/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsIdGet
     *
     * Returns one timesheet record
     *
     * @param int $id Timesheet record ID to fetch (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetEntity
     */
    public function apiTimesheetsIdGet($id)
    {
        list($response) = $this->apiTimesheetsIdGetWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiTimesheetsIdGetWithHttpInfo
     *
     * Returns one timesheet record
     *
     * @param int $id Timesheet record ID to fetch (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsIdGetWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsIdGetAsync
     *
     * Returns one timesheet record
     *
     * @param int $id Timesheet record ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdGetAsync($id)
    {
        return $this->apiTimesheetsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsIdGetAsyncWithHttpInfo
     *
     * Returns one timesheet record
     *
     * @param int $id Timesheet record ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsIdGet'
     *
     * @param int $id Timesheet record ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTimesheetsIdGet'
            );
        }

        $resourcePath = '/api/timesheets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsIdMetaPatch
     *
     * Sets the value of a meta-field for an existing timesheet.
     *
     * @param int $id Timesheet record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body4 $body body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetEntity
     */
    public function apiTimesheetsIdMetaPatch($id, $body = null)
    {
        list($response) = $this->apiTimesheetsIdMetaPatchWithHttpInfo($id, $body);

        return $response;
    }

    /**
     * Operation apiTimesheetsIdMetaPatchWithHttpInfo
     *
     * Sets the value of a meta-field for an existing timesheet.
     *
     * @param int $id Timesheet record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body4 $body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsIdMetaPatchWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdMetaPatchRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsIdMetaPatchAsync
     *
     * Sets the value of a meta-field for an existing timesheet.
     *
     * @param int $id Timesheet record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body4 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdMetaPatchAsync($id, $body = null)
    {
        return $this->apiTimesheetsIdMetaPatchAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsIdMetaPatchAsyncWithHttpInfo
     *
     * Sets the value of a meta-field for an existing timesheet.
     *
     * @param int $id Timesheet record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body4 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdMetaPatchAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdMetaPatchRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsIdMetaPatch'
     *
     * @param int $id Timesheet record ID to set the meta-field value for (required)
     * @param \KimaiConsole\Client\Model\Body4 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsIdMetaPatchRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTimesheetsIdMetaPatch'
            );
        }

        $resourcePath = '/api/timesheets/{id}/meta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsIdPatch
     *
     * Update an existing timesheet record
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body body (required)
     * @param int $id Timesheet record ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetEntity
     */
    public function apiTimesheetsIdPatch($body, $id)
    {
        list($response) = $this->apiTimesheetsIdPatchWithHttpInfo($body, $id);

        return $response;
    }

    /**
     * Operation apiTimesheetsIdPatchWithHttpInfo
     *
     * Update an existing timesheet record
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body (required)
     * @param int $id Timesheet record ID to update (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsIdPatchWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdPatchRequest($body, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsIdPatchAsync
     *
     * Update an existing timesheet record
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body (required)
     * @param int $id Timesheet record ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdPatchAsync($body, $id)
    {
        return $this->apiTimesheetsIdPatchAsyncWithHttpInfo($body, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsIdPatchAsyncWithHttpInfo
     *
     * Update an existing timesheet record
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body (required)
     * @param int $id Timesheet record ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdPatchAsyncWithHttpInfo($body, $id)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdPatchRequest($body, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsIdPatch'
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body (required)
     * @param int $id Timesheet record ID to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsIdPatchRequest($body, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiTimesheetsIdPatch'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTimesheetsIdPatch'
            );
        }

        $resourcePath = '/api/timesheets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsIdRestartPatch
     *
     * Restarts a previously stopped timesheet record for the current user
     *
     * @param int $id Timesheet record ID to restart (required)
     * @param \KimaiConsole\Client\Model\Body3 $body body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetEntity
     */
    public function apiTimesheetsIdRestartPatch($id, $body = null)
    {
        list($response) = $this->apiTimesheetsIdRestartPatchWithHttpInfo($id, $body);

        return $response;
    }

    /**
     * Operation apiTimesheetsIdRestartPatchWithHttpInfo
     *
     * Restarts a previously stopped timesheet record for the current user
     *
     * @param int $id Timesheet record ID to restart (required)
     * @param \KimaiConsole\Client\Model\Body3 $body (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsIdRestartPatchWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdRestartPatchRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsIdRestartPatchAsync
     *
     * Restarts a previously stopped timesheet record for the current user
     *
     * @param int $id Timesheet record ID to restart (required)
     * @param \KimaiConsole\Client\Model\Body3 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdRestartPatchAsync($id, $body = null)
    {
        return $this->apiTimesheetsIdRestartPatchAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsIdRestartPatchAsyncWithHttpInfo
     *
     * Restarts a previously stopped timesheet record for the current user
     *
     * @param int $id Timesheet record ID to restart (required)
     * @param \KimaiConsole\Client\Model\Body3 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdRestartPatchAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdRestartPatchRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsIdRestartPatch'
     *
     * @param int $id Timesheet record ID to restart (required)
     * @param \KimaiConsole\Client\Model\Body3 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsIdRestartPatchRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTimesheetsIdRestartPatch'
            );
        }

        $resourcePath = '/api/timesheets/{id}/restart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsIdStopPatch
     *
     * Stops an active timesheet record
     *
     * @param int $id Timesheet record ID to stop (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetEntity
     */
    public function apiTimesheetsIdStopPatch($id)
    {
        list($response) = $this->apiTimesheetsIdStopPatchWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiTimesheetsIdStopPatchWithHttpInfo
     *
     * Stops an active timesheet record
     *
     * @param int $id Timesheet record ID to stop (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsIdStopPatchWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdStopPatchRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsIdStopPatchAsync
     *
     * Stops an active timesheet record
     *
     * @param int $id Timesheet record ID to stop (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdStopPatchAsync($id)
    {
        return $this->apiTimesheetsIdStopPatchAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsIdStopPatchAsyncWithHttpInfo
     *
     * Stops an active timesheet record
     *
     * @param int $id Timesheet record ID to stop (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsIdStopPatchAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsIdStopPatchRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsIdStopPatch'
     *
     * @param int $id Timesheet record ID to stop (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsIdStopPatchRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiTimesheetsIdStopPatch'
            );
        }

        $resourcePath = '/api/timesheets/{id}/stop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsPost
     *
     * Creates a new timesheet record
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetEntity
     */
    public function apiTimesheetsPost($body)
    {
        list($response) = $this->apiTimesheetsPostWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation apiTimesheetsPostWithHttpInfo
     *
     * Creates a new timesheet record
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsPostWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsPostAsync
     *
     * Creates a new timesheet record
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsPostAsync($body)
    {
        return $this->apiTimesheetsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsPostAsyncWithHttpInfo
     *
     * Creates a new timesheet record
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsPostAsyncWithHttpInfo($body)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetEntity';
        $request = $this->apiTimesheetsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsPost'
     *
     * @param \KimaiConsole\Client\Model\TimesheetEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling apiTimesheetsPost'
            );
        }

        $resourcePath = '/api/timesheets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTimesheetsRecentGet
     *
     * Returns the collection of recent user activities
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $begin Only records after this date will be included. Default: today - 1 year (format: HTML5) (optional)
     * @param string $size The amount of entries (default: 10) (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\TimesheetSubCollection[]
     */
    public function apiTimesheetsRecentGet($user = null, $begin = null, $size = null)
    {
        list($response) = $this->apiTimesheetsRecentGetWithHttpInfo($user, $begin, $size);

        return $response;
    }

    /**
     * Operation apiTimesheetsRecentGetWithHttpInfo
     *
     * Returns the collection of recent user activities
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $begin Only records after this date will be included. Default: today - 1 year (format: HTML5) (optional)
     * @param string $size The amount of entries (default: 10) (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\TimesheetSubCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTimesheetsRecentGetWithHttpInfo($user = null, $begin = null, $size = null)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetSubCollection[]';
        $request = $this->apiTimesheetsRecentGetRequest($user, $begin, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\TimesheetSubCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiTimesheetsRecentGetAsync
     *
     * Returns the collection of recent user activities
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $begin Only records after this date will be included. Default: today - 1 year (format: HTML5) (optional)
     * @param string $size The amount of entries (default: 10) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsRecentGetAsync($user = null, $begin = null, $size = null)
    {
        return $this->apiTimesheetsRecentGetAsyncWithHttpInfo($user, $begin, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTimesheetsRecentGetAsyncWithHttpInfo
     *
     * Returns the collection of recent user activities
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $begin Only records after this date will be included. Default: today - 1 year (format: HTML5) (optional)
     * @param string $size The amount of entries (default: 10) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTimesheetsRecentGetAsyncWithHttpInfo($user = null, $begin = null, $size = null)
    {
        $returnType = '\KimaiConsole\Client\Model\TimesheetSubCollection[]';
        $request = $this->apiTimesheetsRecentGetRequest($user, $begin, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiTimesheetsRecentGet'
     *
     * @param string $user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param string $begin Only records after this date will be included. Default: today - 1 year (format: HTML5) (optional)
     * @param string $size The amount of entries (default: 10) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiTimesheetsRecentGetRequest($user = null, $begin = null, $size = null)
    {
        if ($user !== null && !preg_match('/\\d+|all/', $user)) {
            throw new \InvalidArgumentException('invalid value for "user" when calling DefaultApi.apiTimesheetsRecentGet, must conform to the pattern /\\d+|all/.');
        }

        if ($size !== null && !preg_match('/\\d+/', $size)) {
            throw new \InvalidArgumentException('invalid value for "size" when calling DefaultApi.apiTimesheetsRecentGet, must conform to the pattern /\\d+/.');
        }

        $resourcePath = '/api/timesheets/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($user !== null) {
            $queryParams['user'] = ObjectSerializer::toQueryValue($user);
        }
        // query params
        if ($begin !== null) {
            $queryParams['begin'] = ObjectSerializer::toQueryValue($begin);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiUsersGet
     *
     * Returns the collection of all registered users
     *
     * @param string $visible Visibility status to filter users. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, username, alias, email (default: username) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\UserCollection[]
     */
    public function apiUsersGet($visible = null, $order_by = null, $order = null, $term = null)
    {
        list($response) = $this->apiUsersGetWithHttpInfo($visible, $order_by, $order, $term);

        return $response;
    }

    /**
     * Operation apiUsersGetWithHttpInfo
     *
     * Returns the collection of all registered users
     *
     * @param string $visible Visibility status to filter users. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, username, alias, email (default: username) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\UserCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiUsersGetWithHttpInfo($visible = null, $order_by = null, $order = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\UserCollection[]';
        $request = $this->apiUsersGetRequest($visible, $order_by, $order, $term);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\UserCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiUsersGetAsync
     *
     * Returns the collection of all registered users
     *
     * @param string $visible Visibility status to filter users. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, username, alias, email (default: username) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiUsersGetAsync($visible = null, $order_by = null, $order = null, $term = null)
    {
        return $this->apiUsersGetAsyncWithHttpInfo($visible, $order_by, $order, $term)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiUsersGetAsyncWithHttpInfo
     *
     * Returns the collection of all registered users
     *
     * @param string $visible Visibility status to filter users. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, username, alias, email (default: username) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiUsersGetAsyncWithHttpInfo($visible = null, $order_by = null, $order = null, $term = null)
    {
        $returnType = '\KimaiConsole\Client\Model\UserCollection[]';
        $request = $this->apiUsersGetRequest($visible, $order_by, $order, $term);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiUsersGet'
     *
     * @param string $visible Visibility status to filter users. Allowed values: 1&#x3D;visible, 2&#x3D;hidden, 3&#x3D;all (default: 1) (optional)
     * @param string $order_by The field by which results will be ordered. Allowed values: id, username, alias, email (default: username) (optional)
     * @param string $order The result order. Allowed values: ASC, DESC (default: ASC) (optional)
     * @param string $term Free search term (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiUsersGetRequest($visible = null, $order_by = null, $order = null, $term = null)
    {
        if ($visible !== null && !preg_match('/1|2|3/', $visible)) {
            throw new \InvalidArgumentException('invalid value for "visible" when calling DefaultApi.apiUsersGet, must conform to the pattern /1|2|3/.');
        }

        if ($order_by !== null && !preg_match('/id|username|alias|email/', $order_by)) {
            throw new \InvalidArgumentException('invalid value for "order_by" when calling DefaultApi.apiUsersGet, must conform to the pattern /id|username|alias|email/.');
        }

        if ($order !== null && !preg_match('/ASC|DESC/', $order)) {
            throw new \InvalidArgumentException('invalid value for "order" when calling DefaultApi.apiUsersGet, must conform to the pattern /ASC|DESC/.');
        }

        if ($term !== null && !preg_match('/[a-zA-Z0-9 \\-,:]+/', $term)) {
            throw new \InvalidArgumentException('invalid value for "term" when calling DefaultApi.apiUsersGet, must conform to the pattern /[a-zA-Z0-9 \\-,:]+/.');
        }

        $resourcePath = '/api/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($visible !== null) {
            $queryParams['visible'] = ObjectSerializer::toQueryValue($visible);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($term !== null) {
            $queryParams['term'] = ObjectSerializer::toQueryValue($term);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiUsersIdGet
     *
     * Return one user entity
     *
     * @param int $id User ID to fetch (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\UserEntity
     */
    public function apiUsersIdGet($id)
    {
        list($response) = $this->apiUsersIdGetWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiUsersIdGetWithHttpInfo
     *
     * Return one user entity
     *
     * @param int $id User ID to fetch (required)
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\UserEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiUsersIdGetWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\UserEntity';
        $request = $this->apiUsersIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\UserEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiUsersIdGetAsync
     *
     * Return one user entity
     *
     * @param int $id User ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiUsersIdGetAsync($id)
    {
        return $this->apiUsersIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiUsersIdGetAsyncWithHttpInfo
     *
     * Return one user entity
     *
     * @param int $id User ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiUsersIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\KimaiConsole\Client\Model\UserEntity';
        $request = $this->apiUsersIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiUsersIdGet'
     *
     * @param int $id User ID to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiUsersIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiUsersIdGet'
            );
        }

        $resourcePath = '/api/users/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiUsersMeGet
     *
     * Return the current user entity
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\UserEntity
     */
    public function apiUsersMeGet()
    {
        list($response) = $this->apiUsersMeGetWithHttpInfo();

        return $response;
    }

    /**
     * Operation apiUsersMeGetWithHttpInfo
     *
     * Return the current user entity
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\UserEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiUsersMeGetWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\UserEntity';
        $request = $this->apiUsersMeGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\UserEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiUsersMeGetAsync
     *
     * Return the current user entity
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiUsersMeGetAsync()
    {
        return $this->apiUsersMeGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiUsersMeGetAsyncWithHttpInfo
     *
     * Return the current user entity
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiUsersMeGetAsyncWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\UserEntity';
        $request = $this->apiUsersMeGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiUsersMeGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiUsersMeGetRequest()
    {
        $resourcePath = '/api/users/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiVersionGet
     *
     * Returns information about the Kimai release
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \KimaiConsole\Client\Model\Version
     */
    public function apiVersionGet()
    {
        list($response) = $this->apiVersionGetWithHttpInfo();

        return $response;
    }

    /**
     * Operation apiVersionGetWithHttpInfo
     *
     * Returns information about the Kimai release
     *
     *
     * @throws \KimaiConsole\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \KimaiConsole\Client\Model\Version, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiVersionGetWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\Version';
        $request = $this->apiVersionGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\KimaiConsole\Client\Model\Version',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiVersionGetAsync
     *
     * Returns information about the Kimai release
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiVersionGetAsync()
    {
        return $this->apiVersionGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiVersionGetAsyncWithHttpInfo
     *
     * Returns information about the Kimai release
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiVersionGetAsyncWithHttpInfo()
    {
        $returnType = '\KimaiConsole\Client\Model\Version';
        $request = $this->apiVersionGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiVersionGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiVersionGetRequest()
    {
        $resourcePath = '/api/version';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if ($apiKey !== null) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
